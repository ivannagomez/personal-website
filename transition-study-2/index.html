<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Transition Study - Ivanna Gomez</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/models/imgs/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/models/imgs/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/models/imgs/favicon-16x16.png">
  <link rel="manifest" href="/models/imgs/site.webmanifest">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E❤️%3C/text%3E%3C/svg%3E">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Pixelify+Sans:wght@400..700&display=swap" rel="stylesheet">

  <style>
    @font-face {
      font-family: 'Yipes Regular';
      src: url('../models/imgs/fonts/Yipes Regular.otf') format('opentype');
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'IBM Plex Mono', monospace;
      overflow-x: hidden;
      scroll-behavior: smooth;
    }

    .container {
      height: 100vh;
      scroll-snap-type: y mandatory;
    }

    .bgds-img {
      height: 100vh;
      width: auto;
      min-width: 100%;
      object-position: center;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1;
    }

    .bgd-img {
      height: auto;
      max-height: 252vh;
      width: calc(100vh * 1344 / 896);
      min-width: 100%;
      object-position: center;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      z-index: 0;
    }

    .pp-img {
      height: auto;
      width: 100%;
      object-position: center;
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%) translateY(100%);
      opacity: 0;
      transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.8s ease-in-out;
      z-index: 4;
    }

    .pp-img.enter {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    .pp-img.exit {
      transform: translateX(-50%) translateY(100%);
      opacity: 0;
    }

    .bgd-section {
      height: calc(100vh * 1344 / 896 * 1424 / 848);
      overflow: visible;
    }

    .bgd-section:not(:first-child) {
      margin-top: -100vh;
    }

    .scene-text {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      z-index: 3 !important;
      max-width: 400px;
      padding: 30px;
      background: rgba(255, 0, 0, 0);
      color: white;
      border-radius: 10px;
      opacity: 0;
      transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.6s ease-in-out;
      pointer-events: none;
    }

    .scene-text.active {
      opacity: 1 !important;
    }

    .scene-text.parallax-up {
      transform: translateY(-60%);
    }

    .scene-text.parallax-down {
      transform: translateY(-40%);
    }

    .scene-text h2 {
      font-size: 2rem;
      margin-bottom: 15px;
      font-weight: 600;
    }

    .scene-text p {
      font-size: 1rem;
      line-height: 1.6;
      opacity: 0.9;
    }

    .landing-title-div {
      top: 41%;
      right: 5%;
      color: #e1bc49;
      width: 70%;
      max-width: 70%;
      text-align: end;
      display: flex;
      flex-direction: column;
      align-content: flex-end;
      flex-wrap: wrap;
    }
    .landing-title-div h1 {
      font-family: 'Yipes Regular', sans-serif;
      font-size: 18vw;
      letter-spacing: -0.05em;
      line-height: 0.7;
      font-weight: 100;
    }
    .landing-title-div p {
      max-width: 535px;
      width: 95%;
      align-self: flex-end;
      font-weight: 600;
      line-height: 1.1;
      font-size: 18px;
    }
    
  </style>
</head>

<body>
  <div class="container" id="container">
    <div class="scene" data-scene="1">
     <section id="scene-1" class="bgd-section">
      <img class="bgd-img" src="../models/imgs/transition-study/bgd-2.png">
      <img class="bgds-img transition-all" src="../models/imgs/transition-study/bgds-1.png">
      <div class="scene-text landing-title-div" data-scene="1">
        <!--<h2>The Beginning</h2>
        <p>A journey starts with a single step into the unknown. The world unfolds before us, revealing mysteries and wonders that await discovery.</p>
        -->
      <!--<img style="max-height: 100vh; max-width: 100vw;" src="../models/imgs/transition-study/text-1.png">-->
      <h1>transitions</h1>
      <p>an ivanna study on viewport transition coding, ai image model training, and creative world building</p>
      </div>
     </section>
     <section id="scene-2" class="bgd-section">
      <img class="bgd-img" src="../models/imgs/transition-study/bgd-3.png">
      <img class="bgds-img transition-all" src="../models/imgs/transition-study/bgds-2.png">
      <div class="scene-text" data-scene="2">
        <!-- <h2>Rising Path</h2> -->
        <!-- <p>The path ascends through clouds of possibility. Each step upward brings new perspective, new understanding of the world below.</p> -->
      </div>
    </section>
     <section id="scene-3" class="bgd-section">
      <img class="bgd-img" src="../models/imgs/transition-study/bgd-4.png">
      <img class="bgds-img transition-all" src="../models/imgs/transition-study/bgds-3.png">
      <div class="scene-text" data-scene="3">
        <!-- <h2>Transformation</h2> -->
        <!-- <p>Colors shift and blend, reality bends to imagination. This is where dreams take form and possibilities become tangible.</p> -->
      </div>
     </section>
     <section id="scene-4" class="bgd-section">
      <img class="bgd-img" src="../models/imgs/transition-study/bgd-5.png">
      <img class="bgds-img transition-all" src="../models/imgs/transition-study/bgds-4.png">
      <div class="scene-text" data-scene="4">
        <!-- <h2>The Crossing</h2> -->
        <!-- <p>Between worlds we stand, at the threshold of change. The bridge beneath our feet connects what was to what will be.</p> -->
      </div>
     </section>
     <section id="scene-5" class="bgd-section">
      <img class="bgd-img" src="../models/imgs/transition-study/bgd-6.png">
      <img class="bgds-img transition-all" src="../models/imgs/transition-study/bgds-5.png">
      <div class="scene-text" data-scene="5">
        <!-- <h2>Depths Below</h2> -->
        <!-- <p>Descending into the heart of mystery, we find truths hidden in shadow. The deeper we go, the more we understand.</p> -->
      </div>
     </section>
     <section id="scene-6" class="bgd-section">
      <img class="bgd-img" src="../models/imgs/transition-study/bgd-7.png">
      <img class="bgds-img transition-all" src="../models/imgs/transition-study/bgds-6.png">
      <div class="scene-text" data-scene="6">
        <!-- <h2>Convergence</h2> -->
        <!-- <p>All paths lead to this moment. Past and future collide in a symphony of light and shadow, creating something entirely new.</p> -->
      </div>
     </section>
     <section id="scene-7" class="bgd-section">
      <img class="bgd-img" src="../models/imgs/transition-study/bgd-8.png">
      <img class="bgds-img transition-all" src="../models/imgs/transition-study/bgds-7.png">
      <div class="scene-text" data-scene="7">
        <!-- <h2>Illumination</h2> -->
        <!-- <p>Light breaks through the veil, revealing truths long hidden. In this moment of clarity, everything becomes possible.</p> -->
      </div>
     </section>
     <section id="scene-8" class="bgd-section">
      <img class="bgd-img" src="../models/imgs/transition-study/bgd-9.png">
      <img class="bgds-img transition-all" src="../models/imgs/transition-study/bgds-8.png">
      <div class="scene-text" data-scene="8">
        <!-- <h2>Near the End</h2> -->
        <!-- <p>The journey nears completion, but endings are just beginnings in disguise. What we've learned transforms who we'll become.</p> -->
      </div>
     </section>
     <section id="scene-9" class="bgd-section" style="height: 50%;">
      <img class="bgds-img transition-all" src="../models/imgs/transition-study/bgds-9.png">
      <div class="scene-text" data-scene="9">
        <!-- <h2>Full Circle</h2> -->
        <!-- <p>We return to where we started, but nothing is the same. The journey has changed us, and we see with new eyes.</p> -->
      </div>
     </section>
    </div>

  </div>

  <!-- PP Images - Fixed at bottom of viewport -->
  <img class="pp-img" src="../models/imgs/transition-study/pp-1.png">
  <img class="pp-img" src="../models/imgs/transition-study/pp-2.png">
  <img class="pp-img" src="../models/imgs/transition-study/pp-3.png">
  <img class="pp-img" src="../models/imgs/transition-study/pp-4.png">
  <img class="pp-img" src="../models/imgs/transition-study/pp-5.png">
  <img class="pp-img" src="../models/imgs/transition-study/pp-6.png">
  <img class="pp-img" src="../models/imgs/transition-study/pp-7.png">
  <img class="pp-img" src="../models/imgs/transition-study/pp-8.png">
  <img class="pp-img" src="../models/imgs/transition-study/pp-9.png">

  <script>
    // PP Image Animator - Shows pp-img based on which scene ID is in viewport
    document.addEventListener('DOMContentLoaded', () => {
      const ppImages = document.querySelectorAll('.pp-img');
      const sections = document.querySelectorAll('.bgd-section[id^="scene-"]');
      let currentSceneNum = null;

      // Initialize - first pp-img visible, others hidden
      ppImages.forEach((ppImg, index) => {
        if (index === 0) {
          ppImg.classList.add('enter');
          ppImg.classList.remove('exit');
        } else {
          ppImg.classList.add('exit');
          ppImg.classList.remove('enter');
        }
      });
      currentSceneNum = 1; // Start with scene 1

      console.log('PP Image Animator initialized with', ppImages.length, 'images and', sections.length, 'sections');

      // Create Intersection Observer to detect when scenes enter viewport
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // Extract scene number from ID (e.g., "scene-3" → 3)
            const sceneId = entry.target.id;
            const match = sceneId.match(/scene-(\d+)/);

            if (match) {
              const sceneNum = parseInt(match[1], 10);
              console.log(`Scene ${sceneNum} is now visible`);

              // Only animate if this is a different scene
              if (sceneNum !== currentSceneNum) {
                console.log(`Switching from scene ${currentSceneNum} to scene ${sceneNum}`);

                // Exit previous pp-img
                if (currentSceneNum !== null && currentSceneNum > 0) {
                  const prevPpImg = ppImages[currentSceneNum - 1];
                  if (prevPpImg) {
                    prevPpImg.classList.remove('enter');
                    prevPpImg.classList.add('exit');
                  }
                }

                // Enter new pp-img
                const newPpImg = ppImages[sceneNum - 1];
                if (newPpImg) {
                  newPpImg.classList.remove('exit');
                  newPpImg.classList.add('enter');
                  console.log(`PP-${sceneNum} is now visible`);
                }

                currentSceneNum = sceneNum;
              }
            }
          }
        });
      }, {
        threshold: 0.2, // Lower threshold to trigger earlier
        rootMargin: '0px'
      });

      // Observe all sections with scene IDs
      sections.forEach(section => {
        observer.observe(section);
        console.log('Observing section:', section.id);
      });

      // Force check initial visibility after a short delay
      setTimeout(() => {
        sections.forEach(section => {
          const rect = section.getBoundingClientRect();
          if (rect.top >= 0 && rect.top < window.innerHeight) {
            const match = section.id.match(/scene-(\d+)/);
            if (match) {
              const sceneNum = parseInt(match[1], 10);
              if (sceneNum !== currentSceneNum) {
                console.log(`Initial scene detected: ${sceneNum}`);

                // Exit previous pp-img
                if (currentSceneNum !== null && currentSceneNum > 0) {
                  const prevPpImg = ppImages[currentSceneNum - 1];
                  if (prevPpImg) {
                    prevPpImg.classList.remove('enter');
                    prevPpImg.classList.add('exit');
                  }
                }

                // Enter new pp-img
                const newPpImg = ppImages[sceneNum - 1];
                if (newPpImg) {
                  newPpImg.classList.remove('exit');
                  newPpImg.classList.add('enter');
                }

                currentSceneNum = sceneNum;
              }
            }
          }
        });
      }, 100);
    });

    // Text Parallax and Animation System
    document.addEventListener('DOMContentLoaded', () => {
      const container = document.getElementById('container');
      const sceneTexts = document.querySelectorAll('.scene-text');
      const sections = document.querySelectorAll('.bgd-section[id^="scene-"]');
      let currentTextScene = null;
      let lastScrollTop = 0;

      console.log('Text system initialized with', sceneTexts.length, 'text elements');

      // Hide all text initially
      sceneTexts.forEach(text => {
        text.classList.remove('active');
      });

      // Create observer for text visibility based on scene sections
      const textObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const sectionId = entry.target.id;
            const match = sectionId.match(/scene-(\d+)/);

            if (match) {
              const sceneNum = parseInt(match[1], 10);
              console.log(`Text: Scene ${sceneNum} is now visible`);

              // Hide current text
              if (currentTextScene !== null && sceneTexts[currentTextScene - 1]) {
                sceneTexts[currentTextScene - 1].classList.remove('active');
              }

              // Show new text
              const newText = sceneTexts[sceneNum - 1];
              if (newText) {
                newText.classList.add('active');
                console.log(`Text ${sceneNum} is now active`);
              }

              currentTextScene = sceneNum;
            }
          }
        });
      }, {
        threshold: 0.2,
        rootMargin: '0px'
      });

      // Observe all sections
      sections.forEach(section => {
        textObserver.observe(section);
        console.log('Observing section for text:', section.id);
      });

      // Parallax effect on scroll
      let scrollTimer = null;
      container.addEventListener('scroll', () => {
        const scrollTop = container.scrollTop;
        const scrollDirection = scrollTop > lastScrollTop ? 'down' : 'up';

        // Clear previous timer
        if (scrollTimer) {
          clearTimeout(scrollTimer);
        }

        // Apply parallax to active text
        sceneTexts.forEach((text, index) => {
          if (text.classList.contains('active')) {
            console.log(`Applying parallax ${scrollDirection} to text ${index + 1}`);

            // Remove previous parallax classes
            text.classList.remove('parallax-up', 'parallax-down');

            // Apply opposite parallax effect immediately
            if (scrollDirection === 'down') {
              text.classList.add('parallax-up');
            } else {
              text.classList.add('parallax-down');
            }
          }
        });

        // Reset parallax classes after scroll stops
        scrollTimer = setTimeout(() => {
          sceneTexts.forEach(text => {
            text.classList.remove('parallax-up', 'parallax-down');
          });
        }, 200);

        lastScrollTop = scrollTop;
      }, { passive: true });

      // Force initial check
      setTimeout(() => {
        sections.forEach(section => {
          const rect = section.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();

          if (rect.top < containerRect.bottom && rect.bottom > containerRect.top) {
            const match = section.id.match(/scene-(\d+)/);
            if (match) {
              const sceneNum = parseInt(match[1], 10);
              if (sceneTexts[sceneNum - 1]) {
                sceneTexts[sceneNum - 1].classList.add('active');
                currentTextScene = sceneNum;
                console.log(`Initial text ${sceneNum} activated`);
              }
            }
          }
        });
      }, 100);
    });
  </script>
</body>

</html>